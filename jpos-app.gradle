// -----------------------------------------
// LAZY CONSTANTS / SETTINGS
// -----------------------------------------
def target = (project.findProperty('target') ?: 'devel').toString()

// Build the token map once (strings only), OK for config cache.
def targetConfiguration = new Properties().with {
    put('jvm.options', '') // default so ReplaceTokens always has a key.
    put('target', target)
    put('jarname', "${project.name}-${project.version}.jar")
    put('warname', "${project.name}-${project.version}.war")
    put('buildTimestamp', new Date().format("yyyy-MM-dd HH:mm:ss z"))
    put('rootProjectDir', rootProject.projectDir.toString())
    it
}

def cfgFile = rootProject.file("${target}.properties")
if (cfgFile.exists()) {
    cfgFile.withInputStream { targetConfiguration.load(it) }
}

// Derived providers
def installDirProv = layout.buildDirectory.dir("install/${project.name}")
def jarNameProv    = providers.provider {
    (targetConfiguration.get('jarname') ?: "${project.name}-${project.version}.jar").toString()
}
def classPathAttr = configurations.runtimeClasspath.elements.map { fileSet ->
    fileSet.collect { "lib/${it.asFile.name}" }.join(' ')
}

// -----------------------------------------
// JAR TASK (lazy manifest + filename)
// -----------------------------------------
tasks.named('jar', Jar).configure {
    // Make the archive name explicit; avoids later renames that may capture a Project.
    archiveFileName.set(jarNameProv)

    // Declare runtime CP as an input so Class-Path is tracked properly.
    inputs.files(configurations.runtimeClasspath)

    manifest {
        attributes(
            'Implementation-Title': providers.provider { project.name },
            'Implementation-Version': providers.provider { project.version.toString() },
            'Main-Class'          : 'org.jpos.q2.Q2',
            // Provider<String> is supported here; stays lazy/config-cache safe.
            'Class-Path'          : classPathAttr
        )
    }
}

// -----------------------------------------
// COPY SPEC (no direct Task/Project capture)
// -----------------------------------------
def jposCopySpec = objects.copySpec {
    // Text resources w/ token filtering
    from(layout.projectDirectory.dir("src/dist")) {
        exclude 'cfg/*.lmk', 'cfg/*.jks', 'cfg/*.ks',
                '**/*.jpg', '**/*.gif', '**/*.png', '**/*.pdf', '**/*.ico',
                '**/*.war', '**/*.dat', '**/*.ser',
                '**/*.eot', '**/*.svg', '**/*.ttf', '**/*.woff', '**/*.woff2'
        filter(org.apache.tools.ant.filters.ReplaceTokens, [tokens: targetConfiguration])
    }
    // Binary resources (no filtering)
    from(layout.projectDirectory.dir("src/dist")) {
        include 'cfg/*.lmk', 'cfg/*.jks', 'cfg/*.ks',
                '**/*.jpg', '**/*.gif', '**/*.png', '**/*.pdf', '**/*.ico',
                '**/*.war', '**/*.dat', '**/*.ser',
                '**/*.eot', '**/*.svg', '**/*.ttf', '**/*.woff', '**/*.woff2'
    }

    // Pull the jar output via TaskProvider (no direct Task/Project capture, no rename needed)
    from(tasks.named('jar'))

    // Runtime libs
    into('lib') {
        from(configurations.runtimeClasspath) {
            exclude "servlet-api*.jar" // dependency hack
        }
    }

    // Webapps from build/libs
    into('webapps') {
        from(layout.buildDirectory.dir('libs')) {
            include '*.war'
        }
    }
}

// -----------------------------------------
// processResources (track tokens as inputs)
// -----------------------------------------
tasks.named('processResources', ProcessResources).configure {
    // Make token map part of the taskâ€™s inputs so CC/UP-TO-DATE is correct.
    inputs.properties(targetConfiguration as Map<String, ?>)

    duplicatesStrategy = DuplicatesStrategy.INCLUDE
    from(sourceSets.main.resources.srcDirs) {
        include '**/*.properties', '**/*.xml', '**/*.cfg', '**/*.asc'
        filter(org.apache.tools.ant.filters.ReplaceTokens, [tokens: targetConfiguration])
    }
}

// -----------------------------------------
// TASKS (registered, lazy, CC friendly)
// -----------------------------------------
tasks.register('version', JavaExec) {
    description = "Shows jPOS Version"
    classpath(sourceSets.main.runtimeClasspath)
    mainClass.set('org.jpos.q2.Q2')
    args('--version')
}

tasks.register('dist', Tar) {
    description = 'Creates tar distribution'
    compression = Compression.GZIP
    archiveExtension.set('tar.gz')
    into("${project.name}-${project.version}")
    with(jposCopySpec)
}

tasks.register('installApp', Sync) {
    description = 'Installs jPOS based application'
    into(installDirProv)
    with(jposCopySpec)
}

tasks.register('wrapper', Wrapper) {
    description = "Generate gradlew[.bat]"
    // use your current Gradle (adjust if you standardize elsewhere)
    gradleVersion = '8.14.3'
    distributionType = Wrapper.DistributionType.BIN
}

tasks.register('installResources', JavaExec) {
    dependsOn('classes')
    classpath(sourceSets.main.runtimeClasspath)
    mainClass.set('org.jpos.q2.install.Install')
    args("--outputDir=src/dist")
}

tasks.register('viewTests') {
    description = 'Open Test Reports'
    doLast {
        java.awt.Desktop.desktop.browse(
            layout.buildDirectory.file("reports/tests/test/index.html").get().asFile.toURI()
        )
    }
}

